"""
Knowledge Manager - Centralized knowledge base for the DLD to Cursor AI system
"""

import asyncio
import json
import yaml
from typing import Dict, Any, List, Optional, Set
from pathlib import Path
from dataclasses import dataclass
from datetime import datetime
import networkx as nx

from utils.config import Config
from utils.logger import AgentLogger

@dataclass
class KnowledgeEntry:
    """Individual knowledge entry"""
    id: str
    category: str
    title: str
    content: Dict[str, Any]
    tags: Set[str]
    version: str
    created_at: datetime
    updated_at: datetime
    confidence: float
    source: str

@dataclass
class DomainOntology:
    """Domain ontology structure"""
    concepts: Dict[str, Dict[str, Any]]
    relationships: List[Dict[str, Any]]
    hierarchies: Dict[str, List[str]]
    properties: Dict[str, Dict[str, Any]]

class KnowledgeManager:
    """
    Centralized knowledge management system
    
    Functions:
    1. 5G Domain Ontology management
    2. Coding Pattern Library
    3. Prompt Template management  
    4. Success Case Database
    """
    
    def __init__(self, config: Config):
        self.config = config
        self.logger = AgentLogger("KnowledgeManager")
        
        # Knowledge storage
        self.knowledge_entries: Dict[str, KnowledgeEntry] = {}
        self.domain_ontology: Optional[DomainOntology] = None
        self.coding_patterns: Dict[str, Any] = {}
        self.prompt_templates: Dict[str, Any] = {}
        self.success_cases: List[Dict[str, Any]] = []
        
        # Knowledge organization
        self.category_index: Dict[str, Set[str]] = {}
        self.tag_index: Dict[str, Set[str]] = {}
        self.relationship_graph = nx.DiGraph()
        
        # Knowledge base paths
        self.data_path = Path(config.knowledge_base.data_path)
        self.data_path.mkdir(parents=True, exist_ok=True)
        
        # 5G domain knowledge structure
        self.domain_structure = {\n            \"network_functions\": {\n                \"description\": \"5G Core Network Functions\",\n                \"entities\": [\n                    \"AMF\", \"SMF\", \"UPF\", \"PCF\", \"AUSF\", \"UDM\", \"NRF\", \"NSSF\",\n                    \"NEF\", \"NF\", \"SCP\", \"SEPP\", \"5G-EIR\", \"HSS\", \"UDR\"\n                ]\n            },\n            \"interfaces\": {\n                \"description\": \"5G Network Interfaces\",\n                \"entities\": [\n                    \"N1\", \"N2\", \"N3\", \"N4\", \"N6\", \"N8\", \"N9\", \"N10\", \"N11\",\n                    \"N12\", \"N13\", \"N14\", \"N15\", \"N16\", \"N17\", \"N22\", \"Xn\", \"F1\", \"E1\"\n                ]\n            },\n            \"protocols\": {\n                \"description\": \"5G Protocols and Procedures\",\n                \"entities\": [\n                    \"NAS\", \"NGAP\", \"PFCP\", \"HTTP/2\", \"SBI\", \"SCTP\", \"GTP-U\",\n                    \"RRC\", \"PDCP\", \"RLC\", \"MAC\", \"PHY\", \"SDAP\"\n                ]\n            },\n            \"frequency_bands\": {\n                \"description\": \"5G Frequency Bands and Ranges\",\n                \"entities\": [\n                    \"FR1\", \"FR2\", \"sub6\", \"mmWave\", \"n1\", \"n3\", \"n7\", \"n28\",\n                    \"n78\", \"n79\", \"n257\", \"n258\", \"n260\", \"n261\"\n                ]\n            },\n            \"technologies\": {\n                \"description\": \"5G Technologies and Features\",\n                \"entities\": [\n                    \"5G NR\", \"NSA\", \"SA\", \"EN-DC\", \"MIMO\", \"Massive MIMO\",\n                    \"beamforming\", \"carrier aggregation\", \"network slicing\",\n                    \"URLLC\", \"eMBB\", \"mMTC\", \"edge computing\", \"MEC\"\n                ]\n            }\n        }\n    \n    async def initialize(self) -> None:\n        \"\"\"Initialize the knowledge manager\"\"\"\n        self.logger.info(\"Initializing Knowledge Manager\")\n        \n        # Load existing knowledge base\n        await self._load_knowledge_base()\n        \n        # Initialize domain ontology\n        await self._initialize_domain_ontology()\n        \n        # Load coding patterns\n        await self._load_coding_patterns()\n        \n        # Load prompt templates\n        await self._load_prompt_templates()\n        \n        # Load success cases\n        await self._load_success_cases()\n        \n        # Build indices\n        await self._build_indices()\n        \n        self.logger.info(\"Knowledge Manager initialized successfully\")\n    \n    async def shutdown(self) -> None:\n        \"\"\"Shutdown the knowledge manager\"\"\"\n        self.logger.info(\"Shutting down Knowledge Manager\")\n        \n        # Save knowledge base\n        await self._save_knowledge_base()\n    \n    async def is_ready(self) -> bool:\n        \"\"\"Check if knowledge manager is ready\"\"\"\n        return (\n            self.domain_ontology is not None and\n            len(self.coding_patterns) > 0 and\n            len(self.prompt_templates) > 0\n        )\n    \n    # Domain Ontology Methods\n    \n    async def get_domain_concept(self, concept_name: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get domain concept information\"\"\"\n        if not self.domain_ontology:\n            return None\n        \n        return self.domain_ontology.concepts.get(concept_name)\n    \n    async def get_related_concepts(self, concept_name: str) -> List[str]:\n        \"\"\"Get concepts related to the given concept\"\"\"\n        if not self.domain_ontology:\n            return []\n        \n        related = []\n        for relationship in self.domain_ontology.relationships:\n            if relationship[\"source\"] == concept_name:\n                related.append(relationship[\"target\"])\n            elif relationship[\"target\"] == concept_name:\n                related.append(relationship[\"source\"])\n        \n        return list(set(related))\n    \n    async def validate_domain_terminology(self, text: str) -> Dict[str, Any]:\n        \"\"\"Validate 5G domain terminology in text\"\"\"\n        validation_result = {\n            \"valid_terms\": [],\n            \"invalid_terms\": [],\n            \"suggestions\": {},\n            \"coverage_score\": 0.0\n        }\n        \n        if not self.domain_ontology:\n            return validation_result\n        \n        # Extract terms from text\n        words = text.split()\n        all_domain_entities = set()\n        \n        # Collect all known domain entities\n        for category_info in self.domain_structure.values():\n            all_domain_entities.update(category_info[\"entities\"])\n        \n        found_terms = []\n        for word in words:\n            clean_word = word.strip('.,!?()[]{}\"\\'')\n            if clean_word in all_domain_entities:\n                found_terms.append(clean_word)\n                validation_result[\"valid_terms\"].append(clean_word)\n        \n        # Calculate coverage score\n        if len(words) > 0:\n            validation_result[\"coverage_score\"] = len(found_terms) / len(words)\n        \n        return validation_result\n    \n    # Coding Patterns Methods\n    \n    async def get_coding_pattern(self, pattern_name: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get coding pattern by name\"\"\"\n        return self.coding_patterns.get(pattern_name)\n    \n    async def search_coding_patterns(self, query: str, language: Optional[str] = None) -> List[Dict[str, Any]]:\n        \"\"\"Search coding patterns by query\"\"\"\n        results = []\n        query_lower = query.lower()\n        \n        for pattern_name, pattern_data in self.coding_patterns.items():\n            # Check if query matches pattern name or description\n            if (query_lower in pattern_name.lower() or \n                query_lower in pattern_data.get(\"description\", \"\").lower()):\n                \n                # Filter by language if specified\n                if language and pattern_data.get(\"language\") != language:\n                    continue\n                \n                results.append({\n                    \"name\": pattern_name,\n                    \"data\": pattern_data,\n                    \"relevance\": self._calculate_pattern_relevance(query, pattern_data)\n                })\n        \n        # Sort by relevance\n        results.sort(key=lambda x: x[\"relevance\"], reverse=True)\n        return results\n    \n    def _calculate_pattern_relevance(self, query: str, pattern_data: Dict[str, Any]) -> float:\n        \"\"\"Calculate relevance score for pattern matching\"\"\"\n        score = 0.0\n        query_words = set(query.lower().split())\n        \n        # Check pattern name\n        name_words = set(pattern_data.get(\"name\", \"\").lower().split())\n        score += len(query_words.intersection(name_words)) * 0.5\n        \n        # Check description\n        desc_words = set(pattern_data.get(\"description\", \"\").lower().split())\n        score += len(query_words.intersection(desc_words)) * 0.3\n        \n        # Check tags\n        tags = set(pattern_data.get(\"tags\", []))\n        score += len(query_words.intersection(tags)) * 0.2\n        \n        return score\n    \n    # Prompt Template Methods\n    \n    async def get_prompt_template(self, template_name: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get prompt template by name\"\"\"\n        return self.prompt_templates.get(template_name)\n    \n    async def search_prompt_templates(self, domain: str, task_type: str) -> List[Dict[str, Any]]:\n        \"\"\"Search prompt templates by domain and task type\"\"\"\n        results = []\n        \n        for template_name, template_data in self.prompt_templates.items():\n            if (template_data.get(\"domain\") == domain and\n                template_data.get(\"task_type\") == task_type):\n                results.append({\n                    \"name\": template_name,\n                    \"data\": template_data\n                })\n        \n        return results\n    \n    # Success Cases Methods\n    \n    async def add_success_case(self, case_data: Dict[str, Any]) -> str:\n        \"\"\"Add a new success case\"\"\"\n        case_id = f\"case_{len(self.success_cases)}_{int(datetime.now().timestamp())}\"\n        \n        success_case = {\n            \"id\": case_id,\n            \"timestamp\": datetime.now().isoformat(),\n            **case_data\n        }\n        \n        self.success_cases.append(success_case)\n        \n        # Save to persistent storage\n        await self._save_success_case(success_case)\n        \n        return case_id\n    \n    async def get_similar_success_cases(self, current_case: Dict[str, Any]) -> List[Dict[str, Any]]:\n        \"\"\"Find similar success cases for reference\"\"\"\n        similar_cases = []\n        \n        for case in self.success_cases:\n            similarity = self._calculate_case_similarity(current_case, case)\n            if similarity > 0.6:  # Threshold for similarity\n                similar_cases.append({\n                    \"case\": case,\n                    \"similarity\": similarity\n                })\n        \n        # Sort by similarity\n        similar_cases.sort(key=lambda x: x[\"similarity\"], reverse=True)\n        return similar_cases[:5]  # Return top 5 similar cases\n    \n    def _calculate_case_similarity(self, case1: Dict[str, Any], case2: Dict[str, Any]) -> float:\n        \"\"\"Calculate similarity between two cases\"\"\"\n        score = 0.0\n        \n        # Compare domain\n        if case1.get(\"domain\") == case2.get(\"domain\"):\n            score += 0.3\n        \n        # Compare complexity\n        if case1.get(\"complexity\") == case2.get(\"complexity\"):\n            score += 0.2\n        \n        # Compare tags\n        tags1 = set(case1.get(\"tags\", []))\n        tags2 = set(case2.get(\"tags\", []))\n        if tags1 and tags2:\n            tag_similarity = len(tags1.intersection(tags2)) / len(tags1.union(tags2))\n            score += tag_similarity * 0.3\n        \n        # Compare requirements similarity (simplified)\n        req1 = case1.get(\"requirements\", \"\")\n        req2 = case2.get(\"requirements\", \"\")\n        if req1 and req2:\n            req_words1 = set(req1.lower().split())\n            req_words2 = set(req2.lower().split())\n            if req_words1 and req_words2:\n                req_similarity = len(req_words1.intersection(req_words2)) / len(req_words1.union(req_words2))\n                score += req_similarity * 0.2\n        \n        return score\n    \n    # Knowledge Entry Management\n    \n    async def add_knowledge_entry(self, entry: KnowledgeEntry) -> None:\n        \"\"\"Add a new knowledge entry\"\"\"\n        self.knowledge_entries[entry.id] = entry\n        \n        # Update indices\n        await self._update_indices(entry)\n        \n        # Save to persistent storage\n        await self._save_knowledge_entry(entry)\n    \n    async def search_knowledge(self, query: str, category: Optional[str] = None) -> List[KnowledgeEntry]:\n        \"\"\"Search knowledge entries\"\"\"\n        results = []\n        query_words = set(query.lower().split())\n        \n        for entry in self.knowledge_entries.values():\n            # Filter by category if specified\n            if category and entry.category != category:\n                continue\n            \n            # Calculate relevance score\n            score = 0.0\n            \n            # Check title\n            title_words = set(entry.title.lower().split())\n            score += len(query_words.intersection(title_words)) * 0.5\n            \n            # Check tags\n            score += len(query_words.intersection(entry.tags)) * 0.3\n            \n            # Check content (simplified)\n            content_text = str(entry.content).lower()\n            content_words = set(content_text.split())\n            score += len(query_words.intersection(content_words)) * 0.2\n            \n            if score > 0:\n                results.append((entry, score))\n        \n        # Sort by relevance and return entries\n        results.sort(key=lambda x: x[1], reverse=True)\n        return [entry for entry, score in results]\n    \n    # Statistics and Information\n    \n    async def get_statistics(self) -> Dict[str, Any]:\n        \"\"\"Get knowledge base statistics\"\"\"\n        return {\n            \"total_entries\": len(self.knowledge_entries),\n            \"categories\": len(self.category_index),\n            \"coding_patterns\": len(self.coding_patterns),\n            \"prompt_templates\": len(self.prompt_templates),\n            \"success_cases\": len(self.success_cases),\n            \"domain_concepts\": len(self.domain_ontology.concepts) if self.domain_ontology else 0,\n            \"relationships\": len(self.domain_ontology.relationships) if self.domain_ontology else 0\n        }\n    \n    # Private Implementation Methods\n    \n    async def _load_knowledge_base(self) -> None:\n        \"\"\"Load existing knowledge base from storage\"\"\"\n        self.logger.info(\"Loading knowledge base\")\n        \n        # Load knowledge entries\n        entries_file = self.data_path / \"knowledge_entries.json\"\n        if entries_file.exists():\n            try:\n                with open(entries_file, 'r', encoding='utf-8') as f:\n                    entries_data = json.load(f)\n                \n                for entry_data in entries_data:\n                    entry = KnowledgeEntry(\n                        id=entry_data[\"id\"],\n                        category=entry_data[\"category\"],\n                        title=entry_data[\"title\"],\n                        content=entry_data[\"content\"],\n                        tags=set(entry_data[\"tags\"]),\n                        version=entry_data[\"version\"],\n                        created_at=datetime.fromisoformat(entry_data[\"created_at\"]),\n                        updated_at=datetime.fromisoformat(entry_data[\"updated_at\"]),\n                        confidence=entry_data[\"confidence\"],\n                        source=entry_data[\"source\"]\n                    )\n                    self.knowledge_entries[entry.id] = entry\n                    \n            except Exception as e:\n                self.logger.error(f\"Error loading knowledge entries: {str(e)}\")\n    \n    async def _save_knowledge_base(self) -> None:\n        \"\"\"Save knowledge base to storage\"\"\"\n        self.logger.info(\"Saving knowledge base\")\n        \n        # Save knowledge entries\n        entries_file = self.data_path / \"knowledge_entries.json\"\n        try:\n            entries_data = []\n            for entry in self.knowledge_entries.values():\n                entries_data.append({\n                    \"id\": entry.id,\n                    \"category\": entry.category,\n                    \"title\": entry.title,\n                    \"content\": entry.content,\n                    \"tags\": list(entry.tags),\n                    \"version\": entry.version,\n                    \"created_at\": entry.created_at.isoformat(),\n                    \"updated_at\": entry.updated_at.isoformat(),\n                    \"confidence\": entry.confidence,\n                    \"source\": entry.source\n                })\n            \n            with open(entries_file, 'w', encoding='utf-8') as f:\n                json.dump(entries_data, f, indent=2, ensure_ascii=False)\n                \n        except Exception as e:\n            self.logger.error(f\"Error saving knowledge entries: {str(e)}\")\n    \n    async def _initialize_domain_ontology(self) -> None:\n        \"\"\"Initialize 5G domain ontology\"\"\"\n        self.logger.info(\"Initializing domain ontology\")\n        \n        concepts = {}\n        relationships = []\n        hierarchies = {}\n        properties = {}\n        \n        # Build concepts from domain structure\n        for category, category_info in self.domain_structure.items():\n            # Add category as a concept\n            concepts[category] = {\n                \"name\": category,\n                \"description\": category_info[\"description\"],\n                \"type\": \"category\",\n                \"entities\": category_info[\"entities\"]\n            }\n            \n            # Add entities as concepts\n            for entity in category_info[\"entities\"]:\n                concepts[entity] = {\n                    \"name\": entity,\n                    \"description\": f\"{entity} - {category_info['description']}\",\n                    \"type\": \"entity\",\n                    \"category\": category\n                }\n                \n                # Add relationship between category and entity\n                relationships.append({\n                    \"source\": category,\n                    \"target\": entity,\n                    \"type\": \"contains\",\n                    \"weight\": 1.0\n                })\n        \n        # Create domain ontology\n        self.domain_ontology = DomainOntology(\n            concepts=concepts,\n            relationships=relationships,\n            hierarchies=hierarchies,\n            properties=properties\n        )\n    \n    async def _load_coding_patterns(self) -> None:\n        \"\"\"Load coding patterns from storage\"\"\"\n        self.logger.info(\"Loading coding patterns\")\n        \n        patterns_file = self.data_path / \"coding_patterns.yaml\"\n        if patterns_file.exists():\n            try:\n                with open(patterns_file, 'r', encoding='utf-8') as f:\n                    self.coding_patterns = yaml.safe_load(f) or {}\n            except Exception as e:\n                self.logger.error(f\"Error loading coding patterns: {str(e)}\")\n        \n        # Load default patterns if file doesn't exist\n        if not self.coding_patterns:\n            self.coding_patterns = self._get_default_coding_patterns()\n            await self._save_coding_patterns()\n    \n    async def _load_prompt_templates(self) -> None:\n        \"\"\"Load prompt templates from storage\"\"\"\n        self.logger.info(\"Loading prompt templates\")\n        \n        templates_file = self.data_path / \"prompt_templates.yaml\"\n        if templates_file.exists():\n            try:\n                with open(templates_file, 'r', encoding='utf-8') as f:\n                    self.prompt_templates = yaml.safe_load(f) or {}\n            except Exception as e:\n                self.logger.error(f\"Error loading prompt templates: {str(e)}\")\n        \n        # Load default templates if file doesn't exist\n        if not self.prompt_templates:\n            self.prompt_templates = self._get_default_prompt_templates()\n            await self._save_prompt_templates()\n    \n    async def _load_success_cases(self) -> None:\n        \"\"\"Load success cases from storage\"\"\"\n        self.logger.info(\"Loading success cases\")\n        \n        cases_file = self.data_path / \"success_cases.json\"\n        if cases_file.exists():\n            try:\n                with open(cases_file, 'r', encoding='utf-8') as f:\n                    self.success_cases = json.load(f)\n            except Exception as e:\n                self.logger.error(f\"Error loading success cases: {str(e)}\")\n                self.success_cases = []\n    \n    async def _build_indices(self) -> None:\n        \"\"\"Build search indices\"\"\"\n        self.logger.info(\"Building search indices\")\n        \n        # Build category index\n        for entry in self.knowledge_entries.values():\n            if entry.category not in self.category_index:\n                self.category_index[entry.category] = set()\n            self.category_index[entry.category].add(entry.id)\n            \n            # Build tag index\n            for tag in entry.tags:\n                if tag not in self.tag_index:\n                    self.tag_index[tag] = set()\n                self.tag_index[tag].add(entry.id)\n    \n    async def _update_indices(self, entry: KnowledgeEntry) -> None:\n        \"\"\"Update indices with new entry\"\"\"\n        # Update category index\n        if entry.category not in self.category_index:\n            self.category_index[entry.category] = set()\n        self.category_index[entry.category].add(entry.id)\n        \n        # Update tag index\n        for tag in entry.tags:\n            if tag not in self.tag_index:\n                self.tag_index[tag] = set()\n            self.tag_index[tag].add(entry.id)\n    \n    async def _save_knowledge_entry(self, entry: KnowledgeEntry) -> None:\n        \"\"\"Save individual knowledge entry\"\"\"\n        # This would save to individual entry files or database\n        pass\n    \n    async def _save_success_case(self, case: Dict[str, Any]) -> None:\n        \"\"\"Save individual success case\"\"\"\n        cases_file = self.data_path / \"success_cases.json\"\n        try:\n            with open(cases_file, 'w', encoding='utf-8') as f:\n                json.dump(self.success_cases, f, indent=2, ensure_ascii=False)\n        except Exception as e:\n            self.logger.error(f\"Error saving success cases: {str(e)}\")\n    \n    async def _save_coding_patterns(self) -> None:\n        \"\"\"Save coding patterns to storage\"\"\"\n        patterns_file = self.data_path / \"coding_patterns.yaml\"\n        try:\n            with open(patterns_file, 'w', encoding='utf-8') as f:\n                yaml.dump(self.coding_patterns, f, default_flow_style=False, allow_unicode=True)\n        except Exception as e:\n            self.logger.error(f\"Error saving coding patterns: {str(e)}\")\n    \n    async def _save_prompt_templates(self) -> None:\n        \"\"\"Save prompt templates to storage\"\"\"\n        templates_file = self.data_path / \"prompt_templates.yaml\"\n        try:\n            with open(templates_file, 'w', encoding='utf-8') as f:\n                yaml.dump(self.prompt_templates, f, default_flow_style=False, allow_unicode=True)\n        except Exception as e:\n            self.logger.error(f\"Error saving prompt templates: {str(e)}\")\n    \n    def _get_default_coding_patterns(self) -> Dict[str, Any]:\n        \"\"\"Get default coding patterns\"\"\"\n        return {\n            \"5g_network_function\": {\n                \"name\": \"5G Network Function\",\n                \"description\": \"Template for implementing 5G network functions\",\n                \"language\": \"python\",\n                \"tags\": [\"5g\", \"network_function\", \"template\"],\n                \"pattern\": \"\"\"\nclass {FunctionName}NetworkFunction:\n    def __init__(self, config):\n        self.config = config\n        self.logger = logging.getLogger(self.__class__.__name__)\n    \n    async def initialize(self):\n        # Initialize the network function\n        pass\n    \n    async def handle_message(self, message):\n        # Handle incoming messages\n        pass\n    \n    async def send_response(self, response):\n        # Send response messages\n        pass\n\"\"\"\n            },\n            \"protocol_handler\": {\n                \"name\": \"Protocol Handler\",\n                \"description\": \"Template for implementing protocol handlers\",\n                \"language\": \"python\",\n                \"tags\": [\"protocol\", \"handler\", \"template\"],\n                \"pattern\": \"\"\"\nclass {ProtocolName}Handler:\n    def __init__(self):\n        self.logger = logging.getLogger(self.__class__.__name__)\n    \n    async def encode_message(self, data):\n        # Encode message according to protocol\n        pass\n    \n    async def decode_message(self, raw_data):\n        # Decode message according to protocol\n        pass\n    \n    def validate_message(self, message):\n        # Validate message format\n        pass\n\"\"\"\n            }\n        }\n    \n    def _get_default_prompt_templates(self) -> Dict[str, Any]:\n        \"\"\"Get default prompt templates\"\"\"\n        return {\n            \"5g_implementation\": {\n                \"name\": \"5G Implementation Template\",\n                \"domain\": \"5g_telecommunications\",\n                \"task_type\": \"implementation\",\n                \"template\": \"\"\"\n# 5G {Component} Implementation\n\n## System Context\nYou are implementing a {Component} for a 5G telecommunications system.\n\n## Domain Context\n- Follow 3GPP specifications\n- Ensure real-time performance\n- Implement proper error handling\n- Consider scalability and reliability\n\n## Requirements\n{Requirements}\n\n## Technical Specifications\n{TechnicalSpecs}\n\n## Task\nImplement the {Component} with the specified requirements and technical specifications.\n\n## Deliverables\n- Complete implementation with proper error handling\n- Unit tests with good coverage\n- Documentation and usage examples\n\"\"\"\n            },\n            \"5g_optimization\": {\n                \"name\": \"5G Optimization Template\",\n                \"domain\": \"5g_telecommunications\",\n                \"task_type\": \"optimization\",\n                \"template\": \"\"\"\n# 5G Performance Optimization\n\n## System Context\nOptimize the performance of {Component} in a 5G system.\n\n## Current Performance\n{CurrentMetrics}\n\n## Target Performance\n{TargetMetrics}\n\n## Constraints\n- Maintain protocol compliance\n- Preserve existing functionality\n- Consider resource limitations\n\n## Task\nOptimize the {Component} to meet target performance metrics.\n\"\"\"\n            }\n        }
